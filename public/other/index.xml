<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Others on cyp&#39;s Blog</title>
    <link>http://localhost:1313/other/</link>
    <description>Recent content in Others on cyp&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 11 Aug 2025 16:41:26 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/other/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>AI对话-边车模式和服务网格</title>
      <link>http://localhost:1313/other/ai%E5%AF%B9%E8%AF%9D-%E8%BE%B9%E8%BD%A6%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC/</link>
      <pubDate>Mon, 11 Aug 2025 16:41:26 +0800</pubDate>
      <guid>http://localhost:1313/other/ai%E5%AF%B9%E8%AF%9D-%E8%BE%B9%E8%BD%A6%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC/</guid>
      <description>&lt;p&gt;User: 服务网格和边车模式什么意思&#xA;Kimi: 简单来说，&lt;strong&gt;边车模式（Sidecar Pattern）&lt;/strong&gt; 是一种设计思想，而 &lt;strong&gt;服务网格（Service Mesh）&lt;/strong&gt; 是这种模式在大规模微服务场景下的完整实践。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;边车模式&lt;/strong&gt;&lt;br&gt;&#xA;把日志收集、流量控制、服务注册、熔断限流等“控制类”功能从业务代码里抽出来，放到一个独立的进程/容器里（就像摩托车边斗），让它跟主服务一起启动、一起销毁。主服务专心写业务逻辑，所有“杂活”都交给这个 Sidecar 去做，实现“控制与业务”解耦。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;服务网格&lt;/strong&gt;&lt;br&gt;&#xA;当系统有成百上千个微服务时，每个服务都配一个 Sidecar 代理，它们彼此连成一个网状结构，就形成了 Service Mesh。&lt;br&gt;&#xA;• &lt;strong&gt;数据平面&lt;/strong&gt;：所有 Sidecar 代理，负责实际转发流量、做限流、熔断、加密、指标收集等。&lt;br&gt;&#xA;• &lt;strong&gt;控制平面&lt;/strong&gt;：集中下发配置和策略，告诉每个 Sidecar 该怎么转发、限流、路由等。&lt;br&gt;&#xA;这样，开发者只需要写业务代码，其余网络通信、可观测性、安全等能力都由服务网格统一提供，且对应用“零侵入”。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;一句话总结：&lt;strong&gt;边车模式是“给每个服务配一个助手”，服务网格则是“给所有助手连成一个智能网络”&lt;/strong&gt;。&#xA;User: 在 go 后端服务里，边车模式是怎么和业务代码工作的？需要 go 服务开放某一个统一的端口吗&#xA;Kimi: 在 Go 后端服务里，&lt;strong&gt;边车模式（Sidecar）&lt;/strong&gt; 的典型工作方式可以概括为一句话：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;主服务只负责业务逻辑，边车容器作为反向代理负责流量入口、认证、限流等控制逻辑，两者通过本地网络（localhost）通信。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;一具体工作流程以-go-为例&#34;&gt;一、具体工作流程（以 Go 为例）&lt;/h3&gt;&#xA;&lt;h4 id=&#34;1-主服务只开放一个业务端口&#34;&gt;1. 主服务：只开放一个业务端口&lt;/h4&gt;&#xA;&lt;p&gt;你的 Go 服务仅需像往常一样监听一个本地端口（如 &lt;code&gt;:8080&lt;/code&gt;），专注于处理业务请求，&lt;strong&gt;不需要关心认证、日志、限流等控制功能&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// main.go&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;gin&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Default&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;GET&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/ping&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;gin&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Context&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;JSON&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;gin&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;H&lt;/span&gt;{&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;message&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;pong&amp;#34;&lt;/span&gt;})&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;})&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Run&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;:8080&amp;#34;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;2-sidecar作为反向代理监听另一个端口&#34;&gt;2. Sidecar：作为反向代理监听另一个端口&lt;/h4&gt;&#xA;&lt;p&gt;Sidecar 也是一个独立的 Go 程序（或 Envoy、Nginx 等），监听另一个端口（如 &lt;code&gt;:8081&lt;/code&gt;），所有外部流量先打到 Sidecar，再由它转发给主服务。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// sidecar.go&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;gin&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Default&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Any&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/*proxyPath&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;gin&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Context&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;remote&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;url&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Parse&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://localhost:8080&amp;#34;&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// 主服务地址&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;proxy&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;httputil&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;NewSingleHostReverseProxy&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;remote&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;proxy&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ServeHTTP&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Writer&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Request&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;})&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Run&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;:8081&amp;#34;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;&#xA;&lt;h3 id=&#34;二端口和部署说明&#34;&gt;二、端口和部署说明&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;组件&lt;/th&gt;&#xA;          &lt;th&gt;作用&lt;/th&gt;&#xA;          &lt;th&gt;监听端口&lt;/th&gt;&#xA;          &lt;th&gt;暴露方式&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;主服务&lt;/td&gt;&#xA;          &lt;td&gt;业务逻辑&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;:8080&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;仅本地（不对外）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Sidecar&lt;/td&gt;&#xA;          &lt;td&gt;控制逻辑+流量入口&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;:8081&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;对外暴露&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Kubernetes 部署时&lt;/strong&gt;：两个容器放在同一个 Pod，共享网络命名空间，因此主服务只需监听 &lt;code&gt;localhost:8080&lt;/code&gt;，Sidecar 通过 &lt;code&gt;http://localhost:8080&lt;/code&gt; 即可访问主服务。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;服务网格（如 Istio）场景&lt;/strong&gt;：你甚至不需要手写 Sidecar，Istio 会自动注入 Envoy 作为 Sidecar，自动拦截并转发流量，Go 服务只需监听 &lt;code&gt;localhost:8080&lt;/code&gt; 即可。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;三总结一句&#34;&gt;三、总结一句&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;Go 服务不需要做任何特殊改造，只需像往常一样监听本地端口（如 &lt;code&gt;:8080&lt;/code&gt;），Sidecar 会作为独立进程/容器监听另一个端口（如 &lt;code&gt;:8081&lt;/code&gt;）并代理所有流量。&lt;/strong&gt;&#xA;User: 8080 这个端口是跟 sidecar 约定的吗？如果没有约定端口，sidecar 是怎么跟go服务通信的呢&#xA;Kimi: 不是“天然约定”，而是&lt;strong&gt;部署时显式声明&lt;/strong&gt;的。&lt;br&gt;&#xA;Sidecar 能跟 Go 服务通信，是因为在同一 Pod（或同一主机网络）里，&lt;strong&gt;你或运维把主服务监听的端口告诉了 Sidecar&lt;/strong&gt;。如果没人告诉它，它就找不到。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
