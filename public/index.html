<!DOCTYPE html>
<html lang="en">
  <head>
	<meta name="generator" content="Hugo 0.148.2"><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta
    name="description"
    content=""
  />
  
    
      <title>cyp&#39;s Blog</title>
    
  
  <link rel="stylesheet" href="/css/reset.css"/>
  <link rel="stylesheet" href="/css/font.css"/>
  <link rel="stylesheet" href="/css/smigle.css"/>
  
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
</head>

  <body>
    <div id="root">
      <header>
  <div id="brand">
    <a class="icon-link" href="http://localhost:1313/">
      <img
        class="icon"
        src="/images/brandIcon.svg"
      />
    </a>
    <div class="text">
      <a href="http://localhost:1313/"><h1>cyp&#39;s Blog</h1></a>
      <h3>Description about Blog Author</h3>
    </div>
  </div>
  <nav>
    
  </nav>
  <hr />
</header>

      <div id="content">
        
	<main>
		
		
			<article class="summary">
  <a href="http://localhost:1313/posts/other/ai%E5%AF%B9%E8%AF%9D-%E8%BE%B9%E8%BD%A6%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC/">
    <h1 class="title">AI对话-边车模式和服务网格</h1>
    
  </a>
  









  


<div class="post-meta">
  <strong>
    <span>Posted on</span>
    <time>2025-08-11 16:41:26</time>
    
    
  </strong>
 <span> • 930 words</span>
 <span> • 5 minute read</span>
  
</div>

  <div class="content">
    <p><p>User: 服务网格和边车模式什么意思
Kimi: 简单来说，<strong>边车模式（Sidecar Pattern）</strong> 是一种设计思想，而 <strong>服务网格（Service Mesh）</strong> 是这种模式在大规模微服务场景下的完整实践。</p>
<ol>
<li>
<p><strong>边车模式</strong><br>
把日志收集、流量控制、服务注册、熔断限流等“控制类”功能从业务代码里抽出来，放到一个独立的进程/容器里（就像摩托车边斗），让它跟主服务一起启动、一起销毁。主服务专心写业务逻辑，所有“杂活”都交给这个 Sidecar 去做，实现“控制与业务”解耦。</p>
</li>
<li>
<p><strong>服务网格</strong><br>
当系统有成百上千个微服务时，每个服务都配一个 Sidecar 代理，它们彼此连成一个网状结构，就形成了 Service Mesh。<br>
• <strong>数据平面</strong>：所有 Sidecar 代理，负责实际转发流量、做限流、熔断、加密、指标收集等。<br>
• <strong>控制平面</strong>：集中下发配置和策略，告诉每个 Sidecar 该怎么转发、限流、路由等。<br>
这样，开发者只需要写业务代码，其余网络通信、可观测性、安全等能力都由服务网格统一提供，且对应用“零侵入”。</p>
</li>
</ol>
<p>一句话总结：<strong>边车模式是“给每个服务配一个助手”，服务网格则是“给所有助手连成一个智能网络”</strong>。
User: 在 go 后端服务里，边车模式是怎么和业务代码工作的？需要 go 服务开放某一个统一的端口吗
Kimi: 在 Go 后端服务里，<strong>边车模式（Sidecar）</strong> 的典型工作方式可以概括为一句话：</p>
<blockquote>
<p><strong>主服务只负责业务逻辑，边车容器作为反向代理负责流量入口、认证、限流等控制逻辑，两者通过本地网络（localhost）通信。</strong></p></blockquote>
<hr>
<h3 id="一具体工作流程以-go-为例">一、具体工作流程（以 Go 为例）</h3>
<h4 id="1-主服务只开放一个业务端口">1. 主服务：只开放一个业务端口</h4>
<p>你的 Go 服务仅需像往常一样监听一个本地端口（如 <code>:8080</code>），专注于处理业务请求，<strong>不需要关心认证、日志、限流等控制功能</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// main.go</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gin</span>.<span style="color:#a6e22e">Default</span>()
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">GET</span>(<span style="color:#e6db74">&#34;/ping&#34;</span>, <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">gin</span>.<span style="color:#a6e22e">Context</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">JSON</span>(<span style="color:#ae81ff">200</span>, <span style="color:#a6e22e">gin</span>.<span style="color:#a6e22e">H</span>{<span style="color:#e6db74">&#34;message&#34;</span>: <span style="color:#e6db74">&#34;pong&#34;</span>})
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Run</span>(<span style="color:#e6db74">&#34;:8080&#34;</span>)
</span></span></code></pre></div><h4 id="2-sidecar作为反向代理监听另一个端口">2. Sidecar：作为反向代理监听另一个端口</h4>
<p>Sidecar 也是一个独立的 Go 程序（或 Envoy、Nginx 等），监听另一个端口（如 <code>:8081</code>），所有外部流量先打到 Sidecar，再由它转发给主服务。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// sidecar.go</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gin</span>.<span style="color:#a6e22e">Default</span>()
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Any</span>(<span style="color:#e6db74">&#34;/*proxyPath&#34;</span>, <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">gin</span>.<span style="color:#a6e22e">Context</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">remote</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">url</span>.<span style="color:#a6e22e">Parse</span>(<span style="color:#e6db74">&#34;http://localhost:8080&#34;</span>) <span style="color:#75715e">// 主服务地址</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">proxy</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">httputil</span>.<span style="color:#a6e22e">NewSingleHostReverseProxy</span>(<span style="color:#a6e22e">remote</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">proxy</span>.<span style="color:#a6e22e">ServeHTTP</span>(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">Writer</span>, <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">Request</span>)
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Run</span>(<span style="color:#e6db74">&#34;:8081&#34;</span>)
</span></span></code></pre></div><hr>
<h3 id="二端口和部署说明">二、端口和部署说明</h3>
<table>
  <thead>
      <tr>
          <th>组件</th>
          <th>作用</th>
          <th>监听端口</th>
          <th>暴露方式</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>主服务</td>
          <td>业务逻辑</td>
          <td><code>:8080</code></td>
          <td>仅本地（不对外）</td>
      </tr>
      <tr>
          <td>Sidecar</td>
          <td>控制逻辑+流量入口</td>
          <td><code>:8081</code></td>
          <td>对外暴露</td>
      </tr>
  </tbody>
</table>
<ul>
<li><strong>Kubernetes 部署时</strong>：两个容器放在同一个 Pod，共享网络命名空间，因此主服务只需监听 <code>localhost:8080</code>，Sidecar 通过 <code>http://localhost:8080</code> 即可访问主服务。</li>
<li><strong>服务网格（如 Istio）场景</strong>：你甚至不需要手写 Sidecar，Istio 会自动注入 Envoy 作为 Sidecar，自动拦截并转发流量，Go 服务只需监听 <code>localhost:8080</code> 即可。</li>
</ul>
<hr>
<h3 id="三总结一句">三、总结一句</h3>
<p><strong>Go 服务不需要做任何特殊改造，只需像往常一样监听本地端口（如 <code>:8080</code>），Sidecar 会作为独立进程/容器监听另一个端口（如 <code>:8081</code>）并代理所有流量。</strong>
User: 8080 这个端口是跟 sidecar 约定的吗？如果没有约定端口，sidecar 是怎么跟go服务通信的呢
Kimi: 不是“天然约定”，而是<strong>部署时显式声明</strong>的。<br>
Sidecar 能跟 Go 服务通信，是因为在同一 Pod（或同一主机网络）里，<strong>你或运维把主服务监听的端口告诉了 Sidecar</strong>。如果没人告诉它，它就找不到。</p></p>
    
      <a href="http://localhost:1313/posts/other/ai%E5%AF%B9%E8%AF%9D-%E8%BE%B9%E8%BD%A6%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC/">Read more...</a>
    
  </div>
</article>

		
			<article class="summary">
  <a href="http://localhost:1313/posts/go/myfirst-blog/">
    <h1 class="title">Myfirst Blog</h1>
    
  </a>
  









  


<div class="post-meta">
  <strong>
    <span>Posted on</span>
    <time>2025-08-11 15:00:02</time>
    
    
  </strong>
 <span> • 14 words</span>
 <span> • 1 minute read</span>
  
</div>

  <div class="content">
    <p><h2 id="introduction">Introduction</h2>
<p>This is <strong>bold</strong> text, and this is <em>emphasized</em> text.</p>
<p>Visit the <a href="https://gohugo.io">Hugo</a> website!</p></p>
    
  </div>
</article>

		
			<article class="summary">
  <a href="http://localhost:1313/posts/go/ai%E5%AF%B9%E8%AF%9D-singleflight%E5%AE%9E%E7%8E%B0/">
    <h1 class="title">Go singleflight 源码分析    </h1>
    
  </a>
  









  


<div class="post-meta">
  <strong>
    <span>Posted on</span>
    <time>2025-08-07 17:40:00</time>
    
    
  </strong>
 <span> • 4305 words</span>
 <span> • 21 minute read</span>
  
</div>

  <div class="content">
    <p><hr>
<p><strong>User</strong></p>
<p>这是什么原因</p>
<hr>
<p><strong>Cursor</strong></p>
<p>我需要查看当前打开的文件内容以及相关的错误信息来帮助您诊断问题。让我先检查一下您当前正在查看的文件。</p>
<p>我看到您的光标在第73行，这是一个panic错误处理的位置。让我检查一下是否有任何编译错误或运行时错误信息。</p>
<p>让我检查一下项目的构建状态和可能的错误：</p>
<hr>
<p><strong>User</strong></p>
<p>翻一下</p>
<hr>
<p><strong>Cursor</strong></p>
<p>我看到您在查看 <code>singleflight</code> 包的代码。让我帮您翻译一下您选中的这段注释：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// Do executes and returns the results of the given function, making</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// sure that only one execution is in-flight for a given key at a</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// time. If a duplicate comes in, the duplicate caller waits for the</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// original to complete and receives the same results.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// The return value shared indicates whether v was given to multiple callers.</span>
</span></span></code></pre></div><p><strong>中文翻译：</strong></p></p>
    
      <a href="http://localhost:1313/posts/go/ai%E5%AF%B9%E8%AF%9D-singleflight%E5%AE%9E%E7%8E%B0/">Read more...</a>
    
  </div>
</article>

		
			<article class="summary">
  <a href="http://localhost:1313/posts/go/go%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/">
    <h1 class="title">Go 内存分配、逃逸分析与优化机制详解</h1>
    
  </a>
  









  


<div class="post-meta">
  <strong>
    <span>Posted on</span>
    <time>2025-04-27 16:05:00</time>
    
    
  </strong>
 <span> • 359 words</span>
 <span> • 2 minute read</span>
  
</div>

  <div class="content">
    <p><hr>
<h2 id="1-interface-的类型断言与底层实现">1. interface{} 的类型断言与底层实现</h2>
<h3 id="11-类型断言的语法和用途">1.1 类型断言的语法和用途</h3>
<ul>
<li>
<p><code>input.(type)</code> 只能用于 type switch 语句中，用于判断 interface{} 变量的实际类型，并做类型分支处理。</p>
</li>
<li>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">input</span> <span style="color:#66d9ef">interface</span>{} = <span style="color:#ae81ff">123</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">input</span>.(<span style="color:#66d9ef">type</span>) {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">case</span> <span style="color:#66d9ef">int</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// v 是 int 类型</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">case</span> <span style="color:#66d9ef">string</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// v 是 string 类型</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ul>
<h3 id="12-interface-的底层结构">1.2 interface{} 的底层结构</h3>
<ul>
<li>
<p>interface{} 在 Go 底层实现为一个结构体，包含两个指针：</p>
<ul>
<li><code>_type</code>：指向类型元数据（类型描述信息）</li>
<li><code>data</code>：指向实际数据的指针</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">eface</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">_type</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">_type</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">data</span>  <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ul>
<h3 id="13-类型断言的底层实现">1.3 类型断言的底层实现</h3>
<ul>
<li>当你写 <code>input.(type)</code> 或 <code>input.(SomeType)</code> 时，Go 运行时会：
<ol>
<li>读取 interface{} 变量的 <code>_type</code> 指针。</li>
<li>将其与 case 分支中的类型元数据做比较。</li>
<li>匹配则进入对应分支，并将 data 指针转换为目标类型。</li>
<li>不匹配则继续下一个 case。</li>
</ol>
</li>
<li>相关源码在 Go 的 runtime 包（如 <code>iface.go</code>）中，类型断言的核心函数有 <code>runtime.assertE2I</code>、<code>runtime.assertE2T</code> 等。</li>
</ul>
<h3 id="14-性能影响">1.4 性能影响</h3>
<ul>
<li>类型断言的性能损耗极小，通常只涉及指针比较和类型表查找。</li>
<li>只有在极端高频调用下才可能成为瓶颈，绝大多数业务场景可以放心使用。</li>
</ul>
<hr>
<h2 id="2-interface-数据的存储位置">2. interface{} 数据的存储位置</h2>
<h3 id="21-interface-变量本身">2.1 interface{} 变量本身</h3>
<ul>
<li>interface{} 变量本身（即 eface 结构体）通常分配在栈上。</li>
</ul>
<h3 id="22-interface-指向的数据">2.2 interface{} 指向的数据</h3>
<ul>
<li>interface{} 指向的数据，可能分配在栈上，也可能分配在堆上，<strong>由逃逸分析决定</strong>。</li>
<li>逃逸分析会根据变量的生命周期和使用方式，自动决定分配位置。</li>
</ul>
<h3 id="23-影响逃逸的常见场景">2.3 影响逃逸的常见场景</h3>
<ul>
<li>如果 interface{} 指向的数据只在当前函数内使用，且没有被返回或跨 goroutine 传递，通常会分配在栈上。</li>
<li>如果 interface{} 指向的数据被返回、传递到其他 goroutine、或生命周期不明确，则会分配到堆上。</li>
</ul>
<hr>
<h2 id="3-逃逸分析与分配规则">3. 逃逸分析与分配规则</h2>
<h3 id="31-逃逸分析的作用">3.1 逃逸分析的作用</h3>
<ul>
<li>Go 编译器通过逃逸分析（escape analysis）判断变量是否需要分配到堆上。</li>
<li>逃逸分析的目标是尽量减少堆分配，提高程序性能。</li>
</ul>
<h3 id="32-逃逸分析的常见规则">3.2 逃逸分析的常见规则</h3>
<ul>
<li><strong>struct 返回值</strong>：大概率逃逸到堆上，尤其是大 struct 或返回指针时，但有优化空间（如返回值优化）。</li>
<li><strong>普通类型返回值</strong>：如 int、float、bool 等，通常分配在栈上，除非返回的是指针。</li>
<li><strong>interface{} 返回值</strong>：即使是普通类型，也可能逃逸到堆上，因为 interface{} 需要存储类型信息和数据指针，编译器有时会保守处理。</li>
</ul>
<h3 id="33-逃逸分析的命令">3.3 逃逸分析的命令</h3>
<ul>
<li>
<p>你可以用如下命令查看逃逸分析结果：</p></p>
    
      <a href="http://localhost:1313/posts/go/go%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/">Read more...</a>
    
  </div>
</article>

		
		<div>
  
  1 of 1
  
</div>

	</main>

      </div>
      <footer>
  <hr />
  
  <p class="copyright">
    Copyright © 2025
    <a href="http://localhost:1313/"><strong>Blog Author</strong></a>.
    This work is licensed under the
    <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> license.
  </p>
  <p class="builtWith">
    Built with
    <a href="http://www.gohugo.io/">Hugo</a>,
    using the theme
    <a href="https://gitlab.com/ian-s-mcb/smigle-hugo-theme">smigle</a>,
    which was influenced by the theme
    <a href="https://github.com/sumnerevans/smol">smol</a>.
  </p>
</footer>

    </div>
  </body>
</html>
